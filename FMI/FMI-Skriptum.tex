%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{cite}
\usepackage{color}
\usepackage{listings}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{array}
\usepackage{multirow}


\definecolor{gray}{rgb}{0.8,0.8,0.8}

\DeclareGraphicsRule{.tif}{png}{.png}
{‘convert #1 ‘dirname #1‘/‘basename #1 .tif‘.png}
%opening


\lstset{
	language=inform,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	captionpos=b
}

\begin{document}

	\title{\textbf{Formale Methoden der Informatik}\\ Course 185.291 \\WS2013}
	\author{Lectors: Pichler, Egly \\ Author: Georg Abenthung \\ Matr. Nr.: 0726213
	}
	\date{Oct. 2013}

	\maketitle
	
	\abstract{This document are personal notes to the provided Course-Material.}
	\newpage
	
%	\begin{figure}
%		\centering
%		\includegraphics[width=10cm]{tuwien_logo}
%	\end{figure} 
	
	
	\newpage
\section{Computation and Computability}
\subsection{Problems}
\begin{itemize}
  \item {Problem has a name}
  \item {Infinite set of instances}
  \item {Question}
  \item {Answer (yes/no on decision question)}
  \item There are diferent types of problems
  \item In FMI most problems are decision problems.
  \item A program should solve a problem in a mechanical way! (Can be solved by
  a computer or ,,An algorithm can solve the problem''
  \item Alg. should be simple, understandable(shareable), should terminate and
  should work on ALL possible instances of the problem
  \item Given a problem P, can we write a program that is an algorithm for P
  \item Input is a single String or a list of values (def.)
  \item Our programming language is called \textbf{SIMPLE}
  \item If there doesn't exist a SIMPLE program, there doesn't exist a Java
  program (or Turing machine program) either
 \end{itemize}\begin{framed}Church Turing Thesis:\\ Any algorithm can be programmed
in SIMPLE
\end{framed}


Goldbach's Conjecture can't be proved. (Every even integer greater than 2 is
the sum of two primes) The algorithm to check never terminates until we find a
counterexample. If we would have a program, which could tell us, if an algorithm
terminates, we could answer the Goldbach Conjecture. BUT: It doesn't exist.

\subsection{Halting problem (Page 20)}
We want to show, that the Halting problem is undecidable, and then show, that
the assumption leads to a contradiction.\\

A program will be applied to a program as input string. \\
' \ldots prime \\
'' \ldots doubleprime \\

$\Pi''_h $ \ldots speak ,,Pi sub h doubleprime'' \\

This prove goes back to Allan Touring.
\subsection{Page 23}
Reachable-Code Problem is similiar to prove than Halting problem.
Put some code at the end of the program (Infinite Loop !?!?)

\subsection{Page 24}
Decidability implies Semi-Decidability but not vice-versa.

The halting problem is semi-decidable!
Semi-Decidability: You'll never know if you haven't calculated far enough, or
you'll never reach an end!


\subsection{Page 26}
There are two sources of infinity.
It will halt for instances which reach all lines of code, but the algorithm will
never stop, when there's dead code.

\subsection{Page 27}
Cantor's enumeration. Give an enumeration to two indefinite sets.

\subsection{Page 28}
compare to Sequential Calculus by Goedel

\section{Complexity of Problems and Algorithms}

\subsection{Scope of complexity theory}
Notation of Papadimitriou will be used in this section

\subsection{Page 4}
Does there exist a path between u and v.\\
Outer repeat loop is repeated lineearly often.\\
Inner loop also linearly often. At the end it's cubic runtime.

\subsection{Page 5}
The answer to all question: It doesn't really matter in context of complexity
theory.

\subsection{Page 9}
the ,,Big O Notation'' is used in this lecture. $O(f(n))$\\
Other notions are also reasonable, but we - in complexity theory - use the
Big-O-Notation

Complexity theory doesn't work with \textbf{finite} number of Instances for a
problem $\mathcal{P}$. THe Problem must be generalized before.

\subsection{Page 11 - Notion of O, $\Omega$, and $\Theta$}
the big $\Omega$ notation is the reverse of the O notation

$ O(n^3) $ might be $ 0.5n^3-17n^2 $\ldots


\subsection{Page 12 - Efficiently Solvable}
Can a problem be solved in Polynomial (\textbf{P} or \textbf{PTIME}) time.

\subsection{Page 14}
The Vertexes in a boolean circuit are it's ,,Gates''\\

\subsection{Page 19}
We don't care if we can solve the Problem $\mathcal{P}$ in $O(n)$ or $O(n^4)$.
The only important thing is that we can solve it in \textbf{P}

\subsection{Page 22  - from Boolean Formulas to Circuits}
The boolean Input-Gates correspond with the variables used in the formula.

\subsection{Page 26 - The class NP}
The big problem is, that the search space is Exponential.
THere are $2^n$ possible assignments.

Although we can often find a solution to a problem $\mathcal{P}$ with good
heuristics.

\subsection{Page 29}
$INSTANCES(\mathcal{P})$\ldots Boolean Formulas\\
$CERT$\ldots Models (truth assignments)

\subsection{Page 30 - Definition of the class NP}
see Course material

\subsection{Page 35}
Transform the TSP from an Optimization Problem to a decision problem by
introducing a bound.



\begin{tabular}{p{.5cm}p{.5cm}p{.5cm}p{.5cm}l|l}
1.	&\multicolumn{4}{l|}{Feld über vier Spalten}				& (def 1,2; pr)\\
2.	&	&\multicolumn{3}{l|}{Feld über drei Spalten}			& (def 1,2; pr)\\
3.	&	&\multicolumn{3}{l|}{Feld über drei Spalten}			& (def 1,2; pr)\\
4.	&	& 	&\multicolumn{2}{l|}{Feld über zwei Spalten}		& (def 1,2; pr)\\
5.	&\multicolumn{4}{l|}{Feld über vier Spalten}				& (def 1,2; pr)\\
\end{tabular}

\end{document}
