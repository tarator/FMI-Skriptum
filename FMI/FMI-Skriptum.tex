%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{cite}
\usepackage{color}
\usepackage{listings}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{array}
\usepackage{multirow}


\definecolor{gray}{rgb}{0.8,0.8,0.8}

\DeclareGraphicsRule{.tif}{png}{.png}
{‘convert #1 ‘dirname #1‘/‘basename #1 .tif‘.png}
%opening


\lstset{
	language=inform,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	captionpos=b
}

\begin{document}

	\title{\textbf{Formale Methoden der Informatik}\\ Course 185.291 \\WS2013}
	\author{Lectors: Pichler, Egly \\ Author: Georg Abenthung \\ Matr. Nr.: 0726213
	}
	\date{Oct. 2013}

	\maketitle
	
	\abstract{This document are personal notes to the provided Course-Material.}
	\newpage
	
%	\begin{figure}
%		\centering
%		\includegraphics[width=10cm]{tuwien_logo}
%	\end{figure} 
	
	
	\newpage
\section{Computation and Computability}
\subsection{Problems}
\begin{itemize}
  \item {Problem has a name}
  \item {Infinite set of instances}
  \item {Question}
  \item {Answer (yes/no on decision question)}
  \item There are diferent types of problems
  \item In FMI most problems are decision problems.
  \item A program should solve a problem in a mechanical way! (Can be solved by
  a computer or ,,An algorithm can solve the problem''
  \item Alg. should be simple, understandable(shareable), should terminate and
  should work on ALL possible instances of the problem
  \item Given a problem P, can we write a program that is an algorithm for P
  \item Input is a single String or a list of values (def.)
  \item Our programming language is called \textbf{SIMPLE}
  \item If there doesn't exist a SIMPLE program, there doesn't exist a Java
  program (or Turing machine program) either
 \end{itemize}\begin{framed}Church Turing Thesis:\\ Any algorithm can be programmed
in SIMPLE
\end{framed}


Goldbach's Conjecture can't be proved. (Every even integer greater than 2 is
the sum of two primes) The algorithm to check never terminates until we find a
counterexample. If we would have a program, which could tell us, if an algorithm
terminates, we could answer the Goldbach Conjecture. BUT: It doesn't exist.

\subsection{Halting problem (Page 20)}
We want to show, that the Halting problem is undecidable, and then show, that
the assumption leads to a contradiction.\\

A program will be applied to a program as input string. \\
' \ldots prime \\
'' \ldots doubleprime \\

$\Pi''_h $ \ldots speak ,,Pi sub h doubleprime'' \\

This prove goes back to Allan Touring.
\subsection{Page 23}
Reachable-Code Problem is similiar to prove than Halting problem.
Put some code at the end of the program (Infinite Loop !?!?)

\subsection{Page 24}
Decidability implies Semi-Decidability but not vice-versa.

The halting problem is semi-decidable!
Semi-Decidability: You'll never know if you haven't calculated far enough, or
you'll never reach an end!


\subsection{Page 26}
There are two sources of infinity.
It will halt for instances which reach all lines of code, but the algorithm will
never stop, when there's dead code.

\subsection{Page 27}
Cantor's enumeration. Give an enumeration to two indefinite sets.

\subsection{Page 28}
compare to Sequential Calculus by Goedel

\section{Complexity of Problems and Algorithms}

\subsection{Scope of complexity theory}
Notation of Papadimitriou will be used in this section

\subsection{Page 4}
Does there exist a path between u and v.\\
Outer repeat loop is repeated lineearly often.\\
Inner loop also linearly often. At the end it's cubic runtime.

\subsection{Page 5}
The answer to all question: It doesn't really matter in context of complexity
theory.

\subsection{Page 9}
the ,,Big O Notation'' is used in this lecture. $O(f(n))$\\
Other notions are also reasonable, but we - in complexity theory - use the
Big-O-Notation

Complexity theory doesn't work with \textbf{finite} number of Instances for a
problem $\mathcal{P}$. THe Problem must be generalized before.

\subsection{Page 11 - Notion of O, $\Omega$, and $\Theta$}
the big $\Omega$ notation is the reverse of the O notation

$ O(n^3) $ might be $ 0.5n^3-17n^2 $\ldots


\subsection{Page 12 - Efficiently Solvable}
Can a problem be solved in Polynomial (\textbf{P} or \textbf{PTIME}) time.

\subsection{Page 14}
The Vertexes in a boolean circuit are it's ,,Gates''\\

\subsection{Page 19}
We don't care if we can solve the Problem $\mathcal{P}$ in $O(n)$ or $O(n^4)$.
The only important thing is that we can solve it in \textbf{P}

\subsection{Page 22  - from Boolean Formulas to Circuits}
The boolean Input-Gates correspond with the variables used in the formula.

\subsection{Page 26 - The class NP}
The big problem is, that the search space is Exponential.
THere are $2^n$ possible assignments.

Although we can often find a solution to a problem $\mathcal{P}$ with good
heuristics.

\subsection{Page 29}
$INSTANCES(\mathcal{P})$\ldots Boolean Formulas\\
$CERT$\ldots Models (truth assignments)

\subsection{Page 30 - Definition of the class NP}
see Course material

\subsection{Page 35}
Transform the TSP from an Optimization Problem to a decision problem by
introducing a bound.



\section{Reductions}

This is the most important tool in complexity theory. It's used to compare the
complexity of two problems.

\subsection{Page 3 - Basic Idea}

Recall the TSP.
Compare TSP as a \textbf{Decision Problem} (a.k.a. TSP(D)) vs. the TSP as an
\textbf{optimization Problem}

Construct a:
\begin{itemize}
\item Decision problem using an Alg. for Opt.Problem: Does there exist a tour
which fits in a specific budget (Budget might be calculatet by a TSP-Opt-Alg.)
\item Solution for the Opt.Probl using a Alg. for decision Problem: Use
Binary search.
\end{itemize}

\subsection{Page 4}
\paragraph{We have the following setting:}
\begin{itemize}
  \item Problem A: new Problem
  \item Problem B: old and easy solution available
  \item Use Problem B to solve the new Problem A
  \item we say: A is reduced to problem B. (or $A \leq B$)
\end{itemize}

$ A \stackrel{R}{\Longrightarrow} B $

We assume, that the reduction $R$ is feasible in time. We don't want to talk
about the complexity of the reduction $R$, we want to talk about the complexity
of A and B
\paragraph{Another setting:}
\begin{itemize}
  \item Problem A: known as hard
  \item Problem B: new
  \item Problem B is also hard. (If there is no efficient method for A there
  also doesn't exist a simple solution for B)
\end{itemize}

Complexity. Theory is more interested in the second setting (the negative
example).

\subsection{Page 8}
 \begin{center}
	\fbox{\begin{minipage}{15em}
            \begin{tabbing}
            \hspace*{2em}\= \kill % set the tabbings
 
            R: \> $A \longrightarrow B$ \\
               \> $x \longmapsto R(x)$ \\
               \> $x \in A \Leftrightarrow  R(x) \in B$

            \end{tabbing}
     \end{minipage}}
\end{center}

\subsection{Page 9}

Recall what CNF (Conjunctive Normal Form on PL0) means. The SAT Problem is
NP-Complee (without proof). If only CNF is allowed, the Problem is still
NP-Hard. The same if you would allow any arbitrary structure (e.g. DNF).

with 3-SAT we once more reduce the complexity, by reducing the length of the
clauses to 3. The problem is still as complex.

The reduction from SAT to 3-SAT is complicated and not covered in this lecture.

\subsection{Page 10}
2-SAT is easily solvable.


\subsubsection{Page 10 - Independent Set}
Two points should not be adjacent\ldots

The problem gets hard, when you try to find a set of a size $K$

\subsection{Page 11}

2-SAT $\stackrel{R}{\Longrightarrow}$ REACHABILITY



\subsection{Page 12ff - Example of solving the 2-SAT problem}
We can construct 6 literals (3 variable $x_1, x_2, x_3$)

 \begin{center}
	\fbox{\begin{minipage}{15em}
            \begin{tabbing}
            \hspace*{2em}\= \kill % set the tabbings
 
            $\alpha \rightarrow \beta \equiv \neg \alpha \vee \beta$ \\
            $(\alpha \vee \beta) \equiv \neg \alpha \rightarrow \beta $ \\
            $(\alpha \vee \beta) \equiv \neg \beta \rightarrow \alpha $\\


            \end{tabbing}
     \end{minipage}}
\end{center}


\subsection{Page 16ff - more complex example}

This is a typical way of proving something.


INDEPENDENT SET $\leq$ 3-SAT (Ind.Set at least as hasr than 3-SAT)

3-SAT $\stackrel{R}{\Longrightarrow}$ INDEPENDENT SET
We assume 3-SAT old and hard.

\paragraph{Page 18} Choose one literal per clause and try to set it to true. Be
sure not to assign true to a variable ad it's negation.


\paragraph{Page 19} Divide the equivalence. WE start with the direction from
right to left. Assume that $R(x)$ is a positive instance of B and then show,
that $x$ is a positive instance of A.

K \ldots number of klauses

\paragraph{Page 20} find a truth assignment that $x \in A$
We set those variables true which occur positively in the independent set.



\paragraph{Page 21} Now we have to prove the other direction.

Showing (ii) is trivial we have chosen m literals of m triangles.

Showing (i) is more complicated. Choose an arbitrary pair of vertices and show
it's not adjacent. But it's simpler by choosing an indirect proove.





\subsection{Page 22}

the red stuff is important. 

\subsection{Page 24}
















\end{document}
