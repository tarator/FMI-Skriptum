%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{cite}
\usepackage{color}
\usepackage{listings}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{framed}
\usepackage{array}
\usepackage{multirow}

\newcommand{\tb}[1]{\textbf{#1}}
\newcommand{\entails}[1]{\models{#1}}
\definecolor{gray}{rgb}{0.8,0.8,0.8}

\DeclareGraphicsRule{.tif}{png}{.png}
{‘convert #1 ‘dirname #1‘/‘basename #1 .tif‘.png}
%opening


\lstset{
	language=inform,
	frame=shadowbox,
	rulesepcolor=\color{gray},
	captionpos=b
}

%%% useful macros for Turing machines:
\newcommand{\blank}{\sqcup}
\newcommand{\ssym}{\triangleright}
\newcommand{\esym}{\triangleleft}
\newcommand{\halt}{\mbox{h}}
\newcommand{\yess}{\mbox{``yes''}}
\newcommand{\nos}{\mbox{``no''}}
\newcommand{\lmove}{\leftarrow}
\newcommand{\rmove}{\rightarrow}
\newcommand{\stay}{-}
\newcommand{\diverge}{\nearrow}
\newcommand{\yields}[1]{\stackrel{#1}{\rightarrow}}

\newcommand{\HALTING}{\mbox{\bf HALTING}}

\begin{document}

	\title{\textbf{Formale Methoden der Informatik}\\ Course 185.291 \\WS2013}
	\author{Lectors: Pichler, Egly \\ Author: Georg Abenthung \\ Matr. Nr.: 0726213
	}
	\date{Oct. 2013}

	\maketitle
	
	\abstract{This document are personal notes to the provided Course-Material.}
	\newpage
	
%	\begin{figure}
%		\centering
%		\includegraphics[width=10cm]{tuwien_logo}
%	\end{figure} 
	
	
	\newpage
\section{Computation and Computability}
\subsection{Problems}
\begin{itemize}
  \item {Problem has a name}
  \item {Infinite set of instances}
  \item {Question}
  \item {Answer (yes/no on decision question)}
  \item There are diferent types of problems
  \item In FMI most problems are decision problems.
  \item A program should solve a problem in a mechanical way! (Can be solved by
  a computer or ,,An algorithm can solve the problem''
  \item Alg. should be simple, understandable(shareable), should terminate and
  should work on ALL possible instances of the problem
  \item Given a problem P, can we write a program that is an algorithm for P
  \item Input is a single String or a list of values (def.)
  \item Our programming language is called \textbf{SIMPLE}
  \item If there doesn't exist a SIMPLE program, there doesn't exist a Java
  program (or Turing machine program) either
 \end{itemize}\begin{framed}Church Turing Thesis:\\ Any algorithm can be programmed
in SIMPLE
\end{framed}


Goldbach's Conjecture can't be proved. (Every even integer greater than 2 is
the sum of two primes) The algorithm to check never terminates until we find a
counterexample. If we would have a program, which could tell us, if an algorithm
terminates, we could answer the Goldbach Conjecture. BUT: It doesn't exist.

\subsection{Halting problem (Page 20)}
We want to show, that the Halting problem is undecidable, and then show, that
the assumption leads to a contradiction.\\

A program will be applied to a program as input string. \\
' \ldots prime \\
'' \ldots doubleprime \\

$\Pi''_h $ \ldots speak ,,Pi sub h doubleprime'' \\

This prove goes back to Allan Touring.
\subsection{Page 23}
Reachable-Code Problem is similiar to prove than Halting problem.
Put some code at the end of the program (Infinite Loop !?!?)

\subsection{Page 24}
Decidability implies Semi-Decidability but not vice-versa.

The halting problem is semi-decidable!
Semi-Decidability: You'll never know if you haven't calculated far enough, or
you'll never reach an end!


\subsection{Page 26}
There are two sources of infinity.
It will halt for instances which reach all lines of code, but the algorithm will
never stop, when there's dead code.

\subsection{Page 27}
Cantor's enumeration. Give an enumeration to two indefinite sets.

\subsection{Page 28}
compare to Sequential Calculus by Goedel

\section{Complexity of Problems and Algorithms}

\subsection{Scope of complexity theory}
Notation of Papadimitriou will be used in this section

\subsection{Page 4}
Does there exist a path between u and v.\\
Outer repeat loop is repeated lineearly often.\\
Inner loop also linearly often. At the end it's cubic runtime.

\subsection{Page 5}
The answer to all question: It doesn't really matter in context of complexity
theory.

\subsection{Page 9}
the ,,Big O Notation'' is used in this lecture. $O(f(n))$\\
Other notions are also reasonable, but we - in complexity theory - use the
Big-O-Notation

Complexity theory doesn't work with \textbf{finite} number of Instances for a
problem $\mathcal{P}$. THe Problem must be generalized before.

\subsection{Page 11 - Notion of O, $\Omega$, and $\Theta$}
the big $\Omega$ notation is the reverse of the O notation

$ O(n^3) $ might be $ 0.5n^3-17n^2 $\ldots


\subsection{Page 12 - Efficiently Solvable}
Can a problem be solved in Polynomial (\textbf{P} or \textbf{PTIME}) time.

\subsection{Page 14}
The Vertexes in a boolean circuit are it's ,,Gates''\\

\subsection{Page 19}
We don't care if we can solve the Problem $\mathcal{P}$ in $O(n)$ or $O(n^4)$.
The only important thing is that we can solve it in \textbf{P}

\subsection{Page 22  - from Boolean Formulas to Circuits}
The boolean Input-Gates correspond with the variables used in the formula.

\subsection{Page 26 - The class NP}
The big problem is, that the search space is Exponential.
THere are $2^n$ possible assignments.

Although we can often find a solution to a problem $\mathcal{P}$ with good
heuristics.

\subsection{Page 29}
$INSTANCES(\mathcal{P})$\ldots Boolean Formulas\\
$CERT$\ldots Models (truth assignments)

\subsection{Page 30 - Definition of the class NP}
see Course material

\subsection{Page 35}
Transform the TSP from an Optimization Problem to a decision problem by
introducing a bound.



\section{Reductions}

This is the most important tool in complexity theory. It's used to compare the
complexity of two problems.

\subsection{Page 3 - Basic Idea}

Recall the TSP.
Compare TSP as a \textbf{Decision Problem} (a.k.a. TSP(D)) vs. the TSP as an
\textbf{optimization Problem}

Construct a:
\begin{itemize}
\item Decision problem using an Alg. for Opt.Problem: Does there exist a tour
which fits in a specific budget (Budget might be calculatet by a TSP-Opt-Alg.)
\item Solution for the Opt.Probl using a Alg. for decision Problem: Use
Binary search.
\end{itemize}

\subsection{Page 4}
\paragraph{We have the following setting:}
\begin{itemize}
  \item Problem A: new Problem
  \item Problem B: old and easy solution available
  \item Use Problem B to solve the new Problem A
  \item we say: A is reduced to problem B. (or $A \leq B$)
\end{itemize}

$ A \stackrel{R}{\Longrightarrow} B $

We assume, that the reduction $R$ is feasible in time. We don't want to talk
about the complexity of the reduction $R$, we want to talk about the complexity
of A and B
\paragraph{Another setting:}
\begin{itemize}
  \item Problem A: known as hard
  \item Problem B: new
  \item Problem B is also hard. (If there is no efficient method for A there
  also doesn't exist a simple solution for B)
\end{itemize}

Complexity. Theory is more interested in the second setting (the negative
example).

\subsection{Page 8}
 \begin{center}
	\fbox{\begin{minipage}{15em}
            \begin{tabbing}
            \hspace*{2em}\= \kill % set the tabbings
 
            R: \> $A \longrightarrow B$ \\
               \> $x \longmapsto R(x)$ \\
               \> $x \in A \Leftrightarrow  R(x) \in B$

            \end{tabbing}
     \end{minipage}}
\end{center}

\subsection{Page 9}

Recall what CNF (Conjunctive Normal Form on PL0) means. The SAT Problem is
NP-Complee (without proof). If only CNF is allowed, the Problem is still
NP-Hard. The same if you would allow any arbitrary structure (e.g. DNF).

with 3-SAT we once more reduce the complexity, by reducing the length of the
clauses to 3. The problem is still as complex.

The reduction from SAT to 3-SAT is complicated and not covered in this lecture.

\subsection{Page 10}
2-SAT is easily solvable.


\subsubsection{Page 10 - Independent Set}
Two points should not be adjacent\ldots

The problem gets hard, when you try to find a set of a size $K$

\subsection{Page 11}

2-SAT $\stackrel{R}{\Longrightarrow}$ REACHABILITY



\subsection{Page 12ff - Example of solving the 2-SAT problem}
We can construct 6 literals (3 variable $x_1, x_2, x_3$)

 \begin{center}
	\fbox{\begin{minipage}{15em}
            \begin{tabbing}
            \hspace*{2em}\= \kill % set the tabbings
 
            $\alpha \rightarrow \beta \equiv \neg \alpha \vee \beta$ \\
            $(\alpha \vee \beta) \equiv \neg \alpha \rightarrow \beta $ \\
            $(\alpha \vee \beta) \equiv \neg \beta \rightarrow \alpha $\\


            \end{tabbing}
     \end{minipage}}
\end{center}


\subsection{Page 16ff - more complex example}

This is a typical way of proving something.


INDEPENDENT SET $\leq$ 3-SAT (Ind.Set at least as hasr than 3-SAT)

3-SAT $\stackrel{R}{\Longrightarrow}$ INDEPENDENT SET
We assume 3-SAT old and hard.

\paragraph{Page 18} Choose one literal per clause and try to set it to true. Be
sure not to assign true to a variable ad it's negation.


\paragraph{Page 19} Divide the equivalence. WE start with the direction from
right to left. Assume that $R(x)$ is a positive instance of B and then show,
that $x$ is a positive instance of A.

K \ldots number of klauses

\paragraph{Page 20} find a truth assignment that $x \in A$
We set those variables true which occur positively in the independent set.



\paragraph{Page 21} Now we have to prove the other direction.

Showing (ii) is trivial we have chosen m literals of m triangles.

Showing (i) is more complicated. Choose an arbitrary pair of vertices and show
it's not adjacent. But it's simpler by choosing an indirect proove.





\subsection{Page 22}

the red stuff is important.

ANY(!) two NP-Problems can be reduced to each other. (e.g. the reduction from
3-SAT to INDEPENDENT SET) 

$ \mathcal{P}'_{in NP} \leq 3-SAT \leq IND-SET$ or also $ \mathcal{P}'_{in NP}
\leq IND-SET \leq 3-SAT$

NP is the Class of problems, that can be solved with succinct Certificates. (It
only requires polynomial time to find a whitness)

So, if a problem is for example reducable to SAT we know, that the Problem is
not harder than NP.

$P \subseteq NP \subseteq PSPACE \subseteq EXPTIME$


\subsection{Page 24}

 \begin{center}
	\fbox{\begin{minipage}{15em}
            \begin{tabbing}
            \hspace*{2em}\= \kill % set the tabbings
 			\> $\mathcal{P}' \leq \mathcal{P} \subseteq P$\\
            \> $x \stackrel{R} {\rightarrow} R(x)$ \\
            \end{tabbing}
     \end{minipage}}
\end{center} 


\subsection{Page 26}
Informal Proof

\subsection{Page 27}
The formal solution
 \begin{center}
	\fbox{\begin{minipage}{15em}
            \begin{tabbing}
            \hspace*{2em}\= \kill % set the tabbings
            \> $A \stackrel{R} {\rightarrow} B $ \\
            \> $x \mapsto R(x) $ \\
            \> $x \in A \Leftrightarrow R(x) \in B $
            \end{tabbing}
     \end{minipage}}
\end{center} 






\section{NP-Completeness}

\subsection{Page 3}

2-SAT can be solved in P-Time by reducing it to reachability. SAT and 3-SAT are
NP-Complete (without Proof here.)


\subsection{Page 5}
THis is only a rough proof-sketch, not the whole proof.

\subsection{Page 6}
We are only allowed to assume, that $\mathcal{P}$ has a polynomiable decidable
certificate relation. (Else $\mathcal{P}$ would not be arbitrary.)


\subsection{Page 8}
WE have to show that $SAT \leq 3-SAT$

$\phi $ and $\psi$ must not be logically equivalent.

\subsection{Page 11 - Some NP-Problems}

\subsection{Page 12}
Left: Independent set
Idea: Take the complement graph (on the right side)

With this idea an reduction can be constructed.

\subsubsection{Page 17}


 \begin{center}
	\fbox{\begin{minipage}{15em}
            \begin{tabbing}
            \hspace*{2em}\= \kill % set the tabbings
            3-SAT: \\
            $\phi$ = \> $C_1 \wedge \ldots \wedge C_n $ \\
            \> $ C_i = (l_{i1} \vee l_{i2} \vee l_{i3}) $ \\
        
            \end{tabbing}
     \end{minipage}}
\end{center} 

\subsection{Page 18}
Wheter you make a question more or less restrictive, you can't say beforehand,
if solving the problem becomes easier or harder. 

\subsection{Page 20}
We have good SAT-Solvers, so sometimes it's good to reduce a problem to SAT
first.

\subsection{Page 26}
\subparagraph{Certificate:} Truth assignment is a Certificate in the SAT world.
Mapping is a Certivicate in the Graph world.

\subsection{Page 28}

Instead of a clause-based forumla we could also used a rule-based formula:
$p_1 \wedge p_2 \wedge p_3 \rightarrow p_4  = \neg p_1 \vee \neg p_2 \vee \neg
p_3 \vee p_4$

\subsection{Page 30}
The other direction.

The more subformulas we have, the harder it's getting to prove, that there is a
model.



\section{Other important complexity classes}

\subsection{Page 6}

This implementation is not recursive\ldots

\subsection{Page 7}

Time complexity is one exponation higher than it's space complexity.


\subsection{Page 8 - PSPACE}

We assume, that PSPCE is a bigger class than NP. (not prooved yet.)

\subsection{Page 10 - Tica Tac Toe (TTT)}

No branching for player 1. We only choose one move, which could lead to a
winning-strategy.

Exists-For-All alternation is typical for PSPACE:\\
,,Does there exist \textbf{A} move for
player one, so that for \textbf{ALL} moves of P2 \ldots exists \textbf{A} move
for P1 so that for \textbf{ALL} moves for P2 \ldots''

Don't check all constellations of P1 in a move. Check them one after another.
So the steps of the tree is polynomial bounded. THis immediately gives us a
PSPACE upperbound.

\subsection{Page 11}
The travelling space is exponentially big, but we are not forced to use it.
THis is a property of the game not a property of complexity theory.

\subsection{Page 14}
$P \subseteq PTIME$ \ldots you don't have more time to access the memory more
often \ldots

\subsection{Page 14}
We have two problems, which need PTIME, so we can don't address more than PSPACE
memory.

\subsection{Page 15 - EXPTIME}

,,2 to the power of a polynom.''



\section{Turing machines}

Some proofs are almost impossible to encode in SIMPLE. some are easier to
implement in Turing machines.

\subsection{Page 4 }
Transition table of the turing machine.

\subsection{Page 5}
One sided infinitely tape.

$(s, \ssym{}, 1001)$ means (the cursor position, the symbols on the left side
of the cursor including the cursor, the alphabet on the right side )

We can store a constant amount of information in the states of the turing
machine.


\subsection{Page 8}
the ,,h'' state is used, if we want to produce output. Else the states are
,,yes'' or ,,no''

\subsection{Page 10}

yields with $M^k$ means a state can be reached in $k$ steps.

\subsection{Page 11}
Start and blank symbol are never in the alphabet $\Sigma$

Definition: If a string is element of a Language L, the the TM should output
yes.

\subsection{Page 18}
3 tapes are needed: Input-Tape (RO), Work-Tape (RW), Output-Tape (WO)

\subparagraph{Implement a RO-Tape:} only allow to overwrite with the same
symbol.
\subparagraph{Implement a WO Tape:} only allow the cursor to move to the right.



\subsection{Page 23}

with NTM we have a \textbf{transition relation} instead of a \textbf{transition
function.}

\subsection{Page 25}

If we have at least one ,,YES''-answer, we say, the machine accepts the input.\\
To say no, \textbf{ALL} leavers must have the answer ,,NO''


\section{SAT Problems - Preparatory Concepts}

\subsection{Page 5}
This type of figure is called \tb{Cactus Plot}
In 2002 they solved approx. 40 problems with 2010 Software they solved approx.
170 problems. With hardware of 2010 and problems defined in 2009.

Theese are real-world problems like hardware optimization of IBM.

We use SAT-solvers because they are good and provided for free in Public Domain.


\subsection{Pabge 19}

$ \not\leftrightarrow = XOR$

\subsection{Page 21}
THis kond of translation is called \tb{Structure preserving translation}.

\subsection{Pae 31}
The tree shows all ISF's (Immediate subformulas).


\subsection{Page 33}
\subparagraph{Mapping:} We map all variables to truth-values

There are other representation. Here the \tb{iff} representation is choesn by
Uwe Egly.

\subsection{Page 34}
$\models$ \ldots ,,satifies''

\subsection{Page 35}
The first formula in the example: This is used to prove if the \tb{Modus Ponens}
is sound.

\subparagraph{Modus Ponens:} is an inference rule. from two formulas ,,$\phi$''
and ,,$\phi \rightarrow \psi$'' derives ,,$\psi$''

\subparagraph{Modus Tonens:} from two formulas ,,$\neg \phi$'' and ,,$\phi
\rightarrow \psi$'' we derive ,,$\psi$''

Because we can see here $I$ as an ,,Eigenvariable'' this proof is correct. It
is shown \tb{forall}( $\forall$). So we don't have to introduce an additional 
$\forall$-Quantifier


\subsection{Page 37}
An empty clause is an equivalence for  \tb{falsum}.\\
$W$ \ldots Knowledgebase\\ $\phi$ \ldots query

\subsection{Page 38}
We reduce to \tb{Satisfiability} to reuse SAT-Solver.
The reduction can be done quick (e.g. with a python script.)


\subsection{Different normal forms and translation procedures}

\subsection{Page 44 - NNF translation}
These are the rules to translate a formula into \tb{NNF}. These rules must be
applied in this order.

\subsection{CNF translation}
From the \tb{NNF} we can simply create \tb{CNF} by applying these rules.

\subsection{Page 48 - Tseitin translation}
NFT \ldots Normal form translation

\subsection{Page 53}

$q$ is labelled twice (with $l_1$ and $l_2$) because this
is a non-optimized version.


\subsection{Page 63}
YOu can only show the existing of models, BUT you don't get the same models for 
$\phi$ and $\delta(\phi)$

SFO \ldots Subformula occurence

\subsection{Page 64}

NOT logically equivalent, nly satisfiability-equivalence!








\section{SAT-Problems - Techniques for modern SAT Solvers}

\subsection{Page 2 - Cactus Plot}
What are the reasons for that improvements?

These tests hav been run on a modern hardware with solvers from 2002-2010. So,
the better results are just because of the better implementations of the
SAT-solvers.

In modern solvers not only one step backtracking. THe solvers jump high above\ldots

\subsection{Page 5}
\subparagraph{DLL} \ldots ,,Davis-Loveland-Lodgement'' the authors of the first
paper (also called DPLL )

\subsection{Page 6}
\subparagraph{CDCL} - Conflict Driven Clause Learning solvers

\subsection{Page 7}
Basic idea of solvers.

\subsection{Page 14}
Red-Arrows ($\leftarrow$) mean: Conflict between these two clauses under the
partial assignment. WE are now in a deadlock stage. We can't put away the
conflict.

We now apply the first stop criterium. WE now try to backtrack chronologically.


\subsection{Page 18}

After a few backtracks we get a assignment which satifies all clauses.

\subparagraph{UNIT-Rule} THe blue clauses on the slides are unit (c must be 1
to satisfy this clause) the unit rule detects that and sets c to true. The same
happens to atom d.

This is called \tb{Boolean Constraint Propagation}.

\subsection{Page 19}
Now we have a model. Because every clause is satisfied


\subsection{Page 20}
The status of the clauses change over time, like shown in this table. After
each decision the status change.


\subsection{Page 22}

Horn Clauses: Every clause has at most one positive atom. (But can have many
atoms)

\subsection{Page 23 - Heuristics to select truth assignments}
\subsection{Page 24 - DLIS}

Quite an expensive heuristic. Here we go to the approach to satisfy clauses
quickly.

\subsection{Page 25 - Jeroslov-Wang Heuristic}

You try to get Unit-clauses quickly, because they are not far away of conflicts.
You want to get short clauses here quickly.

\subsection{Page 26 - Basic SAT Algorithm}

\subparagraph{PCP} Boolean Constraint Propagation

\subsection{Page 30 - }
Each node in the IG is a variable assignment.

dl (Decision Level) 0 for unit clauses \ldots You don't have a choice. YOu have
to chose the correct answer for the remaining variable.


\subsection{Page 31}

(sic!) $\neg v_1$ should be $ v_{1}^d $ (dual) here

\subsection{Page 32}
In \tb{S2} we have a UNIT-Clause. We can assign the UNIT value.

Keep in mind: on the slides, we often only see parial IG's!

\subsection{Page 33ff - Example of Implication Graph (IG) GRASP approach}

\subsection{Page 37}
We have a conflict graph with the conflict node $\kappa$

\subsection{Page 39}
It's conflict driven, because we start to learn, after a conflict $\kappa $
occured.

\subsection{Page 43}
How can we learn a clause out of this conflict?

decision levels are increased whenever there is made a new decision

The conslict clause is the negated decision clause.

(sic!) at the bottom we should flip $x_1$ instead to flip $x_6$

\subsection{Page 45}
By backtrack to decision level 6, the PCB automatically flips $x_1$ because of
the newly learned rule. Which auomatically makes $\neg x_1$ becomes unit.


\subsection{Page 48}
We have a conflict $\kappa'$ but we don't have a decision ($x_1$ was unit, not
decided.) Now we could try to go back chronologically to an higher dl. But this
is not a good idea. WE go back to dl 3 because there we have the chance to
change an assignment, else the clause will remain conflicting. The only one
which makes the learned clause $c_11$ non conflicting.


\subsection{Page 53 - first UIP scheme}





\end{document}
